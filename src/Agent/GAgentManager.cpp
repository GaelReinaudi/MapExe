#include "GAgentManager.h"
#include "GAgent.h"
#include "GAgentCreationFilter.h"
#include "GAgentPlugin.h"
#include "GStemCellAgent.h"
#include <QMimeData>
#include <QSettings>
#include <QtGui>
#include "GGroupAgent.h"

GAgentManager::GAgentManager()
 	: m_pCleanUpAgents(new QObjectCleanupHandler())
{
}

GAgentManager::~GAgentManager()
{
}

void GAgentManager::CleanUp()
{
// 2012-06-19 - test for mac crash on exit comment the delete that may erase already destroyed agents
// but this makes windows crash on exit so I uncomment it.
//2012-07-08 	if(m_pCleanUpAgents) {
//2012-07-08 		m_pCleanUpAgents->clear();
//2012-07-08 		delete m_pCleanUpAgents;
//2012-07-08 		m_pCleanUpAgents = 0;
//2012-07-08 	}
}

QList<QString> GAgentManager::RegisteredAgentTypes() const
{
	std::vector<QString> ids = AgentManagerInstance()->RegisteredIds();
	QList<QString> typlist;
	for(int i = 0; i < (int)ids.size(); i++) {
		typlist.append(ids[i]);
	}
	return typlist;
}

GAgent* GAgentManager::CreateNewProgAgent(const QString & className, const QString & uniqueIdentifierName, QObject *parent /*= 0*/) const
{
	if(className.isEmpty()) {
		return 0;
	}
	GAgent* pAg = AgentManagerInstance()->CreateObject(className, uniqueIdentifierName, parent ? parent : AgentManagerInstance());
	if(!pAg) {
		return CreateNewStemCellAgent(className, uniqueIdentifierName, parent ? parent : AgentManagerInstance());
	}
	return pAg;
}

GAgent* GAgentManager::CreateNewProgAgent(const QString & className ) const
{
	GAgent* pAg = AgentManagerInstance()->CreateObject(className, "" /*has to be "" so ID is generated by the Agent*/, AgentManagerInstance());
	if(!pAg) {
		return CreateNewStemCellAgent(className, "", AgentManagerInstance());
	}
	return pAg;
}

GAgent* GAgentManager::CreateNewProgAgent(const QString & className, QObject *parent ) const
{
	GAgent* pAg = AgentManagerInstance()->CreateObject( className, "" /*has to be "" so ID is generated by the Agent*/, parent);
	if(!pAg) {
		return CreateNewStemCellAgent(className, "", parent ? parent : AgentManagerInstance());
	}
	return pAg;
}

GStemCellAgent* GAgentManager::CreateNewStemCellAgent(const QString & className, const QString & uniqueIdentifierName /*= ""*/, QObject *pParent /*= 0*/) const
{
	GStemCellAgent* pStemAg = new GStemCellAgent(pParent, uniqueIdentifierName);
	pStemAg->m_TryBeClassName = className;
	return pStemAg;
}

/////////////////////////////////////////////////////////////////////
/*!
Note that this overload will actually try to CreateNewProgAgent() if theMimeData contains the name of such a class.
Note also that in such a case, the created object has a parent set to 0.
\return: GAgent* : pointer to the GAgent or created GProgAgent object. 0 if no match.
\param:  const QMimeData * theMimeData : from e.g. a DropEvent. It must hasFormat("LabExe/agent.single");
*////////////////////////////////////////////////////////////////////
GAgent* GAgentManager::GetAgent( const QMimeData* theMimeData ) const
{
	// extrapolation from qt help: "Using Drag and Drop with Item Views"
	if(!theMimeData)
		return 0;
	if(!theMimeData->hasFormat("LabExe/agent.single")) 
		return 0;
	QByteArray encodedData = theMimeData->data("LabExe/agent.single");
	QDataStream devStream(&encodedData, QIODevice::ReadOnly);
	if(devStream.atEnd()) 
		return 0;	
	QString devStrIDorClass;
	devStream >> devStrIDorClass;

	GAgent* pTheAgent = AgentManagerInstance()->GetAgent(devStrIDorClass);
	// if there is no return, maybe we can try the CreateNewProgAgent(), just in case the data were from a drop of a GProgAgent.
	if(!pTheAgent)
		pTheAgent = CreateNewProgAgent(devStrIDorClass, 0);
	// we return the result, which is 0 if nothing worked.
	return pTheAgent;
}

void GAgentManager::LoadAgentPlugins()
{
	QStringList pluginFileNames;
	// code taken from the plug and paint Qt example !
	QDir pluginsDir = QDir(qApp->applicationDirPath());
//  qDebug() << pluginsDir;

#if defined(Q_OS_MAC)
    if (pluginsDir.dirName() == "MacOS")
        pluginsDir.cdUp();
#else
    pluginsDir.cdUp();
#endif

	pluginsDir.cd("plugins");
    qDebug() << "Loading plugins from: " << pluginsDir.path();

	// for the folder and each sub-folders in the plugin directory
	foreach(QString dirName, pluginsDir.entryList(QDir::AllDirs | QDir::NoDotDot)) {
		QDir agentDir(pluginsDir);
		agentDir.cd(dirName);
// 		qDebug() << agentDir.absolutePath();
		// for each file in the folder
		foreach(QString fileName, agentDir.entryList(QDir::Files)) {
			QPluginLoader loader(agentDir.absoluteFilePath(fileName), this);
			bool didLoad = loader.isLoaded();
			if(!didLoad) {

			}
			QObject *plugin = loader.instance();
			if(plugin && m_pCleanUpAgents)
				m_pCleanUpAgents->add(plugin);
			GAgentPlugin* pAgentPlugin = qobject_cast<GAgentPlugin*>(plugin);
			// if there is a pAgentPlugin, we register it with the agent manager.
			if(pAgentPlugin) {
				pluginFileNames += fileName;
				pAgentPlugin->RegisterAgentClassInAgentManager();
				m_CreationFilters.append(pAgentPlugin);
			}
		}
	}
	// load manually the group agent filter
	GGroupAgentCreationFilter* pGroupFilter = new GGroupAgentCreationFilter(this);
	m_CreationFilters.append(pGroupFilter);
}

void GAgentManager::Add(GAgent* pAgent)
{
	if(!pAgent)
		return;

// 	QStringList theExistingIds = keys(pAgent);
// 	bool wasAlreadyIn = !theExistingIds.isEmpty();
// 	foreach(const QString & thId, theExistingIds){
// 		remove(thId);
// 	}
	QString theID = pAgent->UniqueSystemID();
 	bool wasAlreadyIn = m_Agent_ID.contains(pAgent);
	if(wasAlreadyIn) { // 2012-09-04 try to remove the previous ID if there was one
		QString prevID = m_Agent_ID.value(pAgent);
		m_ID_Agent.remove(prevID);
	}
	m_ID_Agent.insert(theID, pAgent);
	m_Agent_ID.insert(pAgent, theID);

	if(wasAlreadyIn) {
		return;
	}

	QObject* pParent = pAgent->parent();
	if(!pParent || pParent == this)
		if(m_pCleanUpAgents)
			m_pCleanUpAgents->add(pAgent);

	emit AddedAgent(pAgent);
}

int GAgentManager::Remove(GAgent* pAgent)
{
	pAgent = qobject_cast<GAgent*>(pAgent);
	if(!pAgent)
		return 0;
	QString uniqueIdentifierName = pAgent->UniqueSystemID();
	// bug in Qt: remove() just affect one, not all of, the add()`ed object. 
	if(m_pCleanUpAgents) {
		m_pCleanUpAgents->remove(pAgent);
		m_pCleanUpAgents->remove(pAgent);
		m_pCleanUpAgents->remove(pAgent);
	}
	int idRemoved = m_ID_Agent.remove(uniqueIdentifierName);
	int istancesRemoved = m_Agent_ID.remove(pAgent);

	if(istancesRemoved)
		emit RemovedAgent(pAgent);
	return istancesRemoved;
}

void GAgentManager::PopulateSettings( QSettings& inQsettings )
{
	// top level agents
	QList<GAgent*> listAgents;
	foreach(QObject* pObj, children()) {
		GAgent* pAg = qobject_cast<GAgent*>(pObj);
		if(pAg)
			listAgents.append(pAg);
	}

	SaveListAndItems(inQsettings, "TopLevelAgents", listAgents);
}

void GAgentManager::InterpretSettings( QSettings& fromQsettings )
{
	QStringList strListTypeID = fromQsettings.value("TopLevelAgents").toStringList();
	foreach(QString str_TypeID, strListTypeID) {
		// the type. ex: "GWebPageAgent"
		QString strType = GSerializable::GetTypeFromUniqueTypeID(str_TypeID);
		// if the agent ID already exist, use the corresponding agent
		GAgent* pAg = GetAgent(str_TypeID);
		if(pAg) {
			qDebug() << "Using agent " << str_TypeID;
		}
		else {
			pAg = CreateNewProgAgent(strType, str_TypeID, this);
		}
		if(pAg) {
			fromQsettings.beginGroup(str_TypeID);
			pAg->InterpretSettings(fromQsettings);
			fromQsettings.endGroup();
		}
	}
}

void GAgentManager::Clear()
{
	foreach(GAgent* pAg, AllAgents()) {
		pAg->Destroy();
	}
	m_ID_Agent.clear();
	m_Agent_ID.clear();
}
